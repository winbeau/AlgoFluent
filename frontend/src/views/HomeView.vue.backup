<script setup lang="ts">
import { computed, onMounted, ref, watch } from 'vue'

type NotificationType = 'success' | 'error' | 'info'

interface Notification {
  id: number
  type: NotificationType
  message: string
}

interface Problem {
  id: string
  fileName: string
  fileObj: File
  pageStart: number
  pageEnd: number | null
  extractedText: string
  translation: string
  isExtracting: boolean
  isTranslating: boolean
  error: string
}

interface SplitSegment {
  start: number
  end: number
}

declare global {
  interface Window {
    pdfjsLib?: any
    JSZip?: any
    marked?: any
    MathJax?: {
      typesetPromise?: () => Promise<void>
    }
    handleCodeCopy?: (btn: HTMLElement) => void
    copyToClipboardFallback?: (text: string) => Promise<boolean>
  }
}

const MARKED_SRC = 'https://cdn.jsdelivr.net/npm/marked/marked.min.js'
const PDFJS_SRC = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js'
const PDF_WORKER_SRC = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js'
const JSZIP_SRC = 'https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js'
const MATHJAX_SRC = 'https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js'

const problems = ref<Problem[]>([])
const currentProblemIndex = ref(0)
const contestName = ref('')
const apiKey = ref('')
const showKeyModal = ref(false)
const showZipModal = ref(false)
const isDarkMode = ref(true)
const isCopied = ref(false)
const isProcessingZip = ref(false)
const notifications = ref<Notification[]>([])

const pdfContainerRef = ref<HTMLDivElement | null>(null)
const singleFileInputRef = ref<HTMLInputElement | null>(null)
const zipInputRef = ref<HTMLInputElement | null>(null)
const previewCache = new Map<string, { key: string; el: HTMLElement }>()
// 超高清渲染：使用3-6倍缩放，确保最佳清晰度
const renderScale = Math.min(Math.max(window.devicePixelRatio * 1.5, 3), 6)

const copyIconSvg =
  '<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect width="14" height="14" x="8" y="8" rx="2" ry="2"/><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"/></svg>'
const checkIconSvg =
  '<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="text-green-500"><polyline points="20 6 9 17 4 12"/></svg>'

const currentProblem = computed(() => problems.value[currentProblemIndex.value] ?? null)

const translationHtml = computed(() => {
  const text = currentProblem.value?.translation ?? ''
  if (!text) return ''
  if (typeof window !== 'undefined' && window.marked) {
    return window.marked.parse(text)
  }
  return text.replace(/\n/g, '<br />')
})

const scriptCache = new Map<string, Promise<void>>()
let markedConfigured = false
let lastRenderToken = 0

const loadScript = (src: string, id: string, asyncAttr = false) => {
  if (scriptCache.has(id)) return scriptCache.get(id)!
  if (typeof document !== 'undefined') {
    const existing = document.getElementById(id)
    if (existing) {
      const resolved = Promise.resolve()
      scriptCache.set(id, resolved)
      return resolved
    }
    const deferred = new Promise<void>((resolve, reject) => {
      const script = document.createElement('script')
      script.id = id
      script.src = src
      script.async = asyncAttr
      script.onload = () => resolve()
      script.onerror = () => reject(new Error(`Failed to load ${src}`))
      document.head.appendChild(script)
    })
    scriptCache.set(id, deferred)
    return deferred
  }
  const noop = Promise.resolve()
  scriptCache.set(id, noop)
  return noop
}

const ensureMarkedReady = async () => {
  await loadScript(MARKED_SRC, 'marked-cdn')
  configureMarkedRenderer()
}

const ensurePdfReady = async () => {
  await loadScript(PDFJS_SRC, 'pdfjs-cdn')
  if (window.pdfjsLib) {
    window.pdfjsLib.GlobalWorkerOptions.workerSrc = PDF_WORKER_SRC
  } else {
    throw new Error('PDF.js 未成功加载')
  }
}

const ensureJsZipReady = async () => {
  await loadScript(JSZIP_SRC, 'jszip-cdn')
}

const ensureMathJaxReady = async () => {
  if (!window.MathJax) {
    window.MathJax = {
      tex: {
        inlineMath: [
          ['$', '$'],
          ['\\(', '\\)'],
        ],
        displayMath: [
          ['$$', '$$'],
          ['\\[', '\\]'],
        ],
        processEscapes: true,
      },
      svg: {
        fontCache: 'global',
      },
    }
  }
  await loadScript(MATHJAX_SRC, 'mathjax-cdn', true)
}

const configureMarkedRenderer = () => {
  if (!window.marked || markedConfigured) return
  const renderer = new window.marked.Renderer()
  renderer.code = (code: any, language: string) => {
    let codeContent = ''
    if (typeof code === 'string') codeContent = code
    else if (code && typeof code.text === 'string') codeContent = code.text
    const escaped = codeContent
      .replace(/&/g, '&amp;')
      .replace(/</g, '&lt;')
      .replace(/>/g, '&gt;')
      .replace(/"/g, '&quot;')
      .replace(/'/g, '&#039;')
    return `
      <div class="relative group my-4">
        <button onclick="window.handleCodeCopy(this)"
          class="absolute top-2 right-2 p-1.5 rounded bg-slate-200 dark:bg-slate-700 text-slate-500 dark:text-slate-400 opacity-0 group-hover:opacity-100 transition-opacity hover:bg-slate-300 dark:hover:bg-slate-600 z-10 border border-slate-300 dark:border-slate-600"
          title="复制样例">
          ${copyIconSvg}
        </button>
        <pre><code class="${language || ''}">${escaped}</code></pre>
      </div>
    `
  }
  window.marked.use({
    breaks: true,
    gfm: true,
    renderer,
  })
  markedConfigured = true
}

const notify = (type: NotificationType, message: string) => {
  const id = Date.now() + Math.random()
  notifications.value.push({ id, type, message })
  setTimeout(() => removeNotification(id), 4000)
}

const removeNotification = (id: number) => {
  notifications.value = notifications.value.filter((n) => n.id !== id)
}

const updateProblem = (index: number, patch: Partial<Problem>) => {
  const next = [...problems.value]
  const existing = next[index]
  if (!existing) return
  next[index] = { ...existing, ...patch }
  problems.value = next
}

const updateProblemById = (id: string, patch: Partial<Problem>) => {
  const idx = problems.value.findIndex((p) => p.id === id)
  if (idx !== -1) updateProblem(idx, patch)
  return idx
}

const copyToClipboard = async (text: string) => {
  if (navigator.clipboard && window.isSecureContext) {
    try {
      await navigator.clipboard.writeText(text)
      return true
    } catch (err) {
      console.warn('Clipboard API failed, fallback engaged', err)
    }
  }
  try {
    const textarea = document.createElement('textarea')
    textarea.value = text
    textarea.style.top = '0'
    textarea.style.left = '0'
    textarea.style.position = 'fixed'
    textarea.style.opacity = '0'
    document.body.appendChild(textarea)
    textarea.focus()
    textarea.select()
    const result = document.execCommand('copy')
    document.body.removeChild(textarea)
    return result
  } catch (err) {
    console.error('Fallback copy failed', err)
    return false
  }
}

const handleCodeCopy = async (buttonEl: HTMLElement) => {
  const wrapper = buttonEl.closest('.relative')
  const codeBlock = wrapper?.querySelector('code')
  if (!codeBlock) return
  const text = codeBlock.textContent ?? ''
  const success = await copyToClipboard(text)
  if (success) {
    buttonEl.innerHTML = checkIconSvg
    setTimeout(() => {
      buttonEl.innerHTML = copyIconSvg
    }, 2000)
  } else {
    notify('error', '复制失败，请手动选择复制')
  }
}

const handleAppCopy = async (text: string) => {
  const success = await copyToClipboard(text)
  if (success) {
    isCopied.value = true
    notify('success', '已复制翻译内容')
    setTimeout(() => {
      isCopied.value = false
    }, 2000)
  } else {
    notify('error', '复制失败，请手动复制')
  }
}

const saveApiKey = (key: string) => {
  apiKey.value = key
  localStorage.setItem('deepseek_api_key', key)
  showKeyModal.value = false
  notify('success', 'API Key 已保存')
}

const handleSingleFile = async (file: File) => {
  try {
    await ensurePdfReady()
    const arrayBuffer = await file.arrayBuffer()
    const pdf = await window.pdfjsLib.getDocument({ data: arrayBuffer }).promise
    if (pdf.numPages > 4) {
      const confirmMsg = `检测到此 PDF 有 ${pdf.numPages} 页，可能包含多个题目。\n\n是否尝试自动拆分为"比赛模式"处理？`
      const segments = await analyzeAndSplitPdf(file)
      if (segments && segments.length > 1 && window.confirm(confirmMsg)) {
        await confirmSplit(file, segments)
        return
      }
    }
    previewCache.clear()
    problems.value = [
      {
        id: `single-${Date.now()}`,
        fileName: file.name,
        fileObj: file,
        pageStart: 1,
        pageEnd: pdf.numPages,
        extractedText: '',
        translation: '',
        isExtracting: false,
        isTranslating: false,
        error: '',
      },
    ]
    currentProblemIndex.value = 0
    contestName.value = ''
    notify('success', '文件上传成功')
  } catch (err) {
    console.error(err)
    notify('error', '无法读取 PDF 文件')
  }
}

const analyzeAndSplitPdf = async (file: File) => {
  try {
    await ensurePdfReady()
    const arrayBuffer = await file.arrayBuffer()
    const pdf = await window.pdfjsLib.getDocument({ data: arrayBuffer }).promise
    const totalPages = pdf.numPages
    const segments: SplitSegment[] = []
    let currentStart = 1
    const problemHeaderRegex = /(?:Problem|Task)\s+[A-Z]|\b[A-Z]\.\s+/i
    for (let pageNum = 1; pageNum <= totalPages; pageNum++) {
      const page = await pdf.getPage(pageNum)
      const textContent = await page.getTextContent()
      const snippet = textContent.items
        .map((item: any) => (item.str ? String(item.str) : ''))
        .filter((s: string) => s.trim().length > 0)
        .slice(0, 5)
        .join(' ')
      if (pageNum > 1 && problemHeaderRegex.test(snippet)) {
        segments.push({ start: currentStart, end: pageNum - 1 })
        currentStart = pageNum
      }
    }
    segments.push({ start: currentStart, end: totalPages })
    return segments
  } catch (err) {
    console.error('PDF 分析失败', err)
    return null
  }
}

const confirmSplit = async (file: File, segments: SplitSegment[]) => {
  const generated = segments.map((segment, idx) => {
    const letter = String.fromCharCode(65 + idx)
    return {
      id: `split-${idx}-${Date.now()}`,
      fileName: `Problem ${letter} (P${segment.start}-${segment.end})`,
      fileObj: file,
      pageStart: segment.start,
      pageEnd: segment.end,
      extractedText: '',
      translation: '',
      isExtracting: false,
      isTranslating: false,
      error: '',
    }
  })
  problems.value = generated
  currentProblemIndex.value = 0
  contestName.value = file.name.replace('.pdf', '')
  notify('success', `成功拆分为 ${generated.length} 个题目`)
}

const handleZipFile = async (zipFile: File) => {
  if (!zipFile.name.toLowerCase().endsWith('.zip')) {
    notify('error', '请上传 .zip 格式的文件')
    return
  }
  isProcessingZip.value = true
  try {
    await ensureJsZipReady()
    const zip = await window.JSZip.loadAsync(zipFile)
    const entries: any[] = []
    zip.forEach((relativePath: string, zipEntry: any) => {
      if (!zipEntry.dir && relativePath.toLowerCase().endsWith('.pdf') && !relativePath.includes('__MACOSX')) {
        entries.push(zipEntry)
      }
    })
    if (!entries.length) {
      notify('error', '压缩包内没有找到有效的 PDF 文件')
      return
    }
    entries.sort((a, b) => a.name.localeCompare(b.name))
    const newProblems = await Promise.all(
      entries.map(async (entry, idx) => {
        const blob = await entry.async('blob')
        const simpleName = entry.name.split('/').pop()?.replace('.pdf', '') ?? `Problem ${idx + 1}`
        const file = new File([blob], entry.name.split('/').pop() ?? `Problem_${idx + 1}.pdf`, {
          type: 'application/pdf',
        })
        return {
          id: `zip-${idx}-${Date.now()}`,
          fileName: simpleName,
          fileObj: file,
          pageStart: 1,
          pageEnd: null,
          extractedText: '',
          translation: '',
          isExtracting: false,
          isTranslating: false,
          error: '',
        }
      })
    )
    previewCache.clear()
    problems.value = newProblems
    currentProblemIndex.value = 0
    contestName.value = zipFile.name.replace('.zip', '').replace(/_/g, ' ')
    showZipModal.value = false
    notify('success', `成功解析 ${newProblems.length} 个题目`)
  } catch (err) {
    console.error('Zip Error', err)
    notify('error', '无法解析 ZIP 文件，请确保文件未损坏')
  } finally {
    isProcessingZip.value = false
  }
}

const extractTextForProblem = async (index: number, problem: Problem) => {
  updateProblem(index, { isExtracting: true, error: '' })
  try {
    await ensurePdfReady()
    const arrayBuffer = await problem.fileObj.arrayBuffer()
    const pdf = await window.pdfjsLib.getDocument({ data: arrayBuffer }).promise
    let fullText = ''
    const finalEnd = problem.pageEnd ?? pdf.numPages
    for (let pageNum = problem.pageStart; pageNum <= finalEnd; pageNum++) {
      const page = await pdf.getPage(pageNum)
      const textContent = await page.getTextContent()
      const lines: Record<number, any[]> = {}
      const tolerance = 5
      textContent.items.forEach((item: any) => {
        const y = item.transform[5]
        const existingKey = Object.keys(lines).find((key) => Math.abs(Number(key) - y) < tolerance)
        if (existingKey) lines[existingKey].push(item)
        else lines[y] = [item]
      })
      const sortedKeys = Object.keys(lines).sort((a, b) => Number(b) - Number(a))
      let pageText = ''
      sortedKeys.forEach((key) => {
        const lineItems = lines[Number(key)] ?? []
        lineItems.sort((a: any, b: any) => a.transform[4] - b.transform[4])
        pageText += lineItems.map((item: any) => item.str).join(' ') + '\n'
      })
      fullText += `--- Page ${pageNum} ---\n${pageText}\n\n`
    }
    updateProblem(index, { extractedText: fullText, isExtracting: false })
  } catch (err) {
    console.error('Extract text failed', err)
    updateProblem(index, { isExtracting: false, error: '文本提取失败' })
    notify('error', '提取文本失败，可能是加密的 PDF')
  }
}

const renderPdfPreview = async (problem: Problem) => {
  const container = pdfContainerRef.value
  if (!container) return
  const cacheKey = `${problem.id}-${problem.pageStart}-${problem.pageEnd ?? 'end'}-${renderScale}`
  const cached = previewCache.get(problem.id)
  if (cached && cached.key === cacheKey) {
    container.innerHTML = ''
    container.appendChild(cached.el)
    return
  }
  const token = ++lastRenderToken
  container.innerHTML = ''
  const loadingDiv = document.createElement('div')
  loadingDiv.className =
    'flex flex-col items-center justify-center h-64 text-slate-500 dark:text-slate-400'
  loadingDiv.innerHTML = `<div class="loader mb-4"></div><p>正在渲染预览 (第 ${problem.pageStart} - ${
    problem.pageEnd ?? '?'
  } 页)...</p>`
  container.appendChild(loadingDiv)
  try {
    await ensurePdfReady()
    const arrayBuffer = await problem.fileObj.arrayBuffer()
    const loadingTask = window.pdfjsLib.getDocument({ data: arrayBuffer })
    const pdf = await loadingTask.promise
    if (token !== lastRenderToken) return
    const rendered = document.createElement('div')
    const finalEnd = problem.pageEnd ?? pdf.numPages
    for (let pageNum = problem.pageStart; pageNum <= finalEnd; pageNum++) {
      const page = await pdf.getPage(pageNum)
      // 获取原始尺寸（1倍缩放）
      const viewport = page.getViewport({ scale: 1 })
      // 获取高清渲染视图（renderScale倍）
      const renderViewport = page.getViewport({ scale: renderScale })

      const canvasWrapper = document.createElement('div')
      canvasWrapper.className = 'overflow-hidden relative group'
      canvasWrapper.style.width = '100%'

      const pageBadge = document.createElement('div')
      pageBadge.className =
        'absolute top-2 right-2 bg-black/50 text-white text-xs px-2 py-1 rounded opacity-0 group-hover:opacity-100 transition-opacity pointer-events-none'
      pageBadge.innerText = `Page ${pageNum}`
      canvasWrapper.appendChild(pageBadge)

      const canvas = document.createElement('canvas')
      const context = canvas.getContext('2d', {
        alpha: false,
        desynchronized: true,
        willReadFrequently: false
      })

      // Canvas实际尺寸为超高清尺寸（3-6倍）
      canvas.height = renderViewport.height
      canvas.width = renderViewport.width

      // 启用平滑渲染
      if (context) {
        context.imageSmoothingEnabled = true
        context.imageSmoothingQuality = 'high'
      }

      // CSS显示尺寸：宽度100%自适应，高度按比例
      canvas.style.width = '100%'
      canvas.style.height = 'auto'
      canvas.className = 'block'

      canvasWrapper.appendChild(canvas)
      rendered.appendChild(canvasWrapper)

      // 使用高质量渲染参数
      await page.render({
        canvasContext: context,
        viewport: renderViewport,
        intent: 'display',
        enableWebGL: false,
        renderInteractiveForms: false,
        background: 'white'
      }).promise

      if (token !== lastRenderToken) return
    }
    container.innerHTML = ''
    container.appendChild(rendered)
    previewCache.set(problem.id, { key: cacheKey, el: rendered })
  } catch (err) {
    console.error('PDF render failed', err)
    container.innerHTML = '<div class="text-red-500 p-4">无法渲染预览</div>'
    notify('error', `无法渲染 PDF: ${problem.fileName}`)
  }
}

const translateCurrentProblem = async () => {
  const targetIndex = currentProblemIndex.value
  const targetProblem = problems.value[targetIndex]
  if (!targetProblem) return
  if (!targetProblem.extractedText) {
    notify('info', '请先等待文本提取完成')
    return
  }
  if (!apiKey.value) {
    showKeyModal.value = true
    notify('error', '请先设置 API Key')
    return
  }
  updateProblem(targetIndex, { isTranslating: true, error: '' })
  const systemPrompt = `You are an expert Competitive Programming Translator.\nTranslate the following Algorithm Problem Statement from English to Chinese.\nRULES:\n1. Keep all mathematical formulas in LaTeX format.\n2. Use standard Chinese algorithmic terminology.\n3. Structure the output clearly using Markdown headers.\n4. Reconstruct Sample Input/Output using Markdown Code Blocks.`
  try {
    const response = await fetch('https://api.deepseek.com/chat/completions', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        Authorization: `Bearer ${apiKey.value}`,
      },
      body: JSON.stringify({
        model: 'deepseek-chat',
        messages: [
          { role: 'system', content: systemPrompt },
          { role: 'user', content: `PDF Content (Problem Part):\n\n${targetProblem.extractedText}` },
        ],
        stream: false,
      }),
    })
    if (!response.ok) throw new Error(`API Error: ${response.status}`)
    const data = await response.json()
    const aiText = data.choices?.[0]?.message?.content
    if (!aiText) throw new Error('未获取到翻译结果')
    const finalIndex = problems.value.findIndex((p) => p.id === targetProblem.id)
    if (finalIndex !== -1) {
      updateProblem(finalIndex, { translation: aiText, isTranslating: false })
    }
    notify('success', '翻译完成！')
  } catch (err: any) {
    console.error('Translate failed', err)
    updateProblemById(targetProblem.id, {
      isTranslating: false,
      error: `翻译失败: ${err?.message ?? '未知错误'}`,
    })
    notify('error', `翻译失败: ${err?.message ?? '未知错误'}`)
  }
}

const clearProblems = () => {
  problems.value = []
  contestName.value = ''
  currentProblemIndex.value = 0
  previewCache.clear()
  if (pdfContainerRef.value) pdfContainerRef.value.innerHTML = ''
}

const handleDrop = (event: DragEvent) => {
  event.preventDefault()
  const file = event.dataTransfer?.files?.[0]
  if (!file) return
  if (file.type === 'application/pdf' || file.name.toLowerCase().endsWith('.pdf')) handleSingleFile(file)
  else if (file.name.toLowerCase().endsWith('.zip')) handleZipFile(file)
  else notify('error', '请上传 PDF 或 ZIP 文件')
}

const handleZipDrop = (event: DragEvent) => {
  event.preventDefault()
  const file = event.dataTransfer?.files?.[0]
  if (!file) return
  if (file.name.toLowerCase().endsWith('.zip')) handleZipFile(file)
  else notify('error', '请上传 .zip 文件')
}

watch(
  () => [
    currentProblemIndex.value,
    problems.value.length,
    currentProblem.value?.pageStart,
    currentProblem.value?.pageEnd,
  ],
  () => {
    const problem = currentProblem.value
    if (!problem) {
      if (pdfContainerRef.value) pdfContainerRef.value.innerHTML = ''
      return
    }
    void renderPdfPreview(problem)
    if (!problem.extractedText && !problem.isExtracting) {
      void extractTextForProblem(currentProblemIndex.value, problem)
    }
  },
  { immediate: true }
)

watch(
  () => currentProblem.value?.translation,
  (value) => {
    if (!value) return
    Promise.all([ensureMarkedReady(), ensureMathJaxReady()]).then(() => {
      setTimeout(() => {
        window.MathJax?.typesetPromise?.()
      }, 120)
    })
  }
)

watch(
  isDarkMode,
  (value) => {
    document.documentElement.classList.toggle('dark', value)
  },
  { immediate: true }
)

watch(
  () => problems.value.length,
  (length) => {
    if (length === 0) currentProblemIndex.value = 0
    else if (currentProblemIndex.value >= length) currentProblemIndex.value = 0
  }
)

onMounted(() => {
  window.handleCodeCopy = (btn) => handleCodeCopy(btn as HTMLElement)
  window.copyToClipboardFallback = copyToClipboard
  const storedKey = localStorage.getItem('deepseek_api_key')
  if (storedKey) apiKey.value = storedKey
  else {
    showKeyModal.value = true
    notify('info', '请先设置 API Key 以使用翻译功能')
  }
  ensureMarkedReady()
  ensurePdfReady()
  ensureJsZipReady()
  ensureMathJaxReady()
})
</script>

<template>
  <div :class="['min-h-screen flex flex-col transition-colors duration-300', isDarkMode ? 'dark bg-slate-900 text-slate-100' : 'bg-slate-50 text-slate-800']">
    <div class="fixed bottom-4 right-4 z-50 flex flex-col-reverse gap-2 pointer-events-none">
      <div
        v-for="notif in notifications"
        :key="notif.id"
        class="pointer-events-auto flex items-center gap-3 px-4 py-3 rounded-lg shadow-lg border animate-slide-in"
        :class="[
          notif.type === 'error'
            ? 'bg-red-50 border-red-200 text-red-800 dark:bg-red-900/90 dark:border-red-800 dark:text-red-100'
            : notif.type === 'success'
              ? 'bg-green-50 border-green-200 text-green-800 dark:bg-green-900/90 dark:border-green-800 dark:text-green-100'
              : 'bg-blue-50 border-blue-200 text-blue-800 dark:bg-slate-800/90 dark:border-slate-600 dark:text-blue-100',
        ]"
      >
        <svg v-if="notif.type === 'error'" class="w-5 h-5" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24">
          <circle cx="12" cy="12" r="10" />
          <line x1="12" y1="8" x2="12" y2="12" />
          <line x1="12" y1="16" x2="12.01" y2="16" />
        </svg>
        <svg v-else-if="notif.type === 'success'" class="w-5 h-5" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24">
          <polyline points="20 6 9 17 4 12" />
        </svg>
        <svg v-else class="w-5 h-5" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24">
          <circle cx="12" cy="12" r="10" />
          <line x1="12" y1="16" x2="12" y2="12" />
          <line x1="12" y1="8" x2="12.01" y2="8" />
        </svg>
        <span class="text-sm font-medium">{{ notif.message }}</span>
        <button class="ml-2 hover:opacity-70 inline-flex items-center justify-center" @click="removeNotification(notif.id)">
          <svg class="w-4 h-4" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24">
            <line x1="18" y1="6" x2="6" y2="18" />
            <line x1="6" y1="6" x2="18" y2="18" />
          </svg>
        </button>
      </div>
    </div>

    <header class="border-b shrink-0 transition-colors duration-300 bg-white border-slate-200 dark:bg-slate-800 dark:border-slate-700 flex flex-col">
      <div class="h-16 flex items-center justify-between px-6">
        <div class="flex items-center gap-3">
          <div class="bg-blue-600 p-2 rounded-lg text-white">
            <svg class="w-6 h-6" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24">
              <path d="m5 8 6 6m-7 0 6-6 2-3M2 5h12M7 2h1m14 20-5-10-5 10m1-4h6" />
            </svg>
          </div>
          <h1 class="font-bold text-xl tracking-tight text-slate-800 dark:text-white">
            OJ Translator
            <span class="text-blue-600 dark:text-blue-400 text-sm font-normal ml-2">Powered by DeepSeek</span>
          </h1>
        </div>
        <div class="flex items-center gap-3">
          <button
            class="btn-primary"
            @click="showZipModal = true"
          >
            <svg class="w-4 h-4" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24">
              <path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71" />
              <path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71" />
            </svg>
            比赛多题翻译
          </button>
          <div class="h-6 w-px bg-slate-300 dark:bg-slate-600"></div>
          <button
            class="btn-icon"
            @click="isDarkMode = !isDarkMode"
          >
            <svg v-if="isDarkMode" class="w-5 h-5" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24">
              <circle cx="12" cy="12" r="4" />
              <path d="M12 2v2" />
              <path d="M12 20v2" />
              <path d="m4.93 4.93 1.41 1.41" />
              <path d="m17.66 17.66 1.41 1.41" />
              <path d="M2 12h2" />
              <path d="M20 12h2" />
              <path d="m6.34 17.66-1.41 1.41" />
              <path d="m19.07 4.93-1.41 1.41" />
            </svg>
            <svg v-else class="w-5 h-5" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24">
              <path d="M12 3a6 6 0 0 0 9 9 9 9 0 1 1-9-9Z" />
            </svg>
          </button>
          <button
            class="btn-text"
            @click="showKeyModal = true"
          >
            <svg class="w-4 h-4" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24">
              <circle cx="7.5" cy="15.5" r="5.5" />
              <path d="m21 2-9.6 9.6m-5.9 13L22 7l-3-3" />
            </svg>
            API Key
          </button>
        </div>
      </div>
      <div
        v-if="problems.length > 1 || contestName"
        class="px-6 pb-0 flex items-center border-t border-slate-100 dark:border-slate-700 bg-slate-50 dark:bg-slate-800/50 overflow-x-auto"
      >
        <div
          v-if="contestName"
          class="flex items-center gap-2 mr-6 py-3 text-slate-800 dark:text-slate-100 font-bold whitespace-nowrap"
        >
          <svg class="w-5 h-5" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24">
            <path d="M16 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2" />
            <circle cx="8.5" cy="7" r="4" />
            <polyline points="17 11 19 13 23 9" />
          </svg>
          {{ contestName }}
        </div>
        <div class="flex gap-1 py-2">
          <button
            v-for="(prob, idx) in problems"
            :key="prob.id"
            class="px-4 py-1.5 rounded-md text-sm font-medium transition-all whitespace-nowrap"
            :class="[
              currentProblemIndex === idx
                ? 'bg-white dark:bg-slate-700 text-blue-600 dark:text-blue-400 shadow-sm ring-1 ring-slate-200 dark:ring-slate-600'
                : 'text-slate-500 dark:text-slate-400 hover:bg-slate-200 dark:hover:bg-slate-700/50',
            ]"
            @click="currentProblemIndex = idx"
          >
            {{ prob.fileName }}
          </button>
        </div>
      </div>
    </header>

    <main class="flex-1 flex overflow-hidden">
      <section class="flex-1 border-r flex flex-col min-w-0 transition-colors duration-300 bg-slate-100 border-slate-200 dark:bg-slate-900 dark:border-slate-700">
        <div class="h-14 px-3 border-b font-mono text-sm flex justify-between items-center transition-colors duration-300 bg-slate-50 border-slate-200 text-slate-500 dark:bg-slate-800/50 dark:border-slate-700 dark:text-slate-400">
          <span>{{ currentProblem ? `预览: ${currentProblem.fileName}` : '请上传文件' }}</span>
          <button
            v-if="currentProblem"
            class="text-xs text-red-500 hover:text-red-600 dark:text-red-400"
            @click="clearProblems"
          >
            清空
          </button>
        </div>
        <div class="flex-1 overflow-y-auto relative">
          <div
            v-if="!currentProblem"
            class="h-full m-6 border-2 border-dashed rounded-xl flex flex-col items-center justify-center cursor-pointer border-slate-300 bg-slate-50 text-slate-500 hover:border-blue-500 hover:bg-blue-50 dark:border-slate-700 dark:bg-transparent dark:text-slate-400 dark:hover:bg-slate-800/30"
            @click="singleFileInputRef?.click()"
            @dragover.prevent
            @drop="handleDrop"
          >
            <input
              ref="singleFileInputRef"
              type="file"
              class="hidden"
              accept=".pdf,.zip"
              @change="(event: Event) => {
                const input = event.target as HTMLInputElement
                const file = input.files?.[0]
                if (!file) return
                if (file.type === 'application/pdf' || file.name.toLowerCase().endsWith('.pdf')) handleSingleFile(file)
                else if (file.name.toLowerCase().endsWith('.zip')) handleZipFile(file)
                else notify('error', '不支持的文件格式')
                input.value = ''
              }"
            />
            <svg class="w-12 h-12 mb-4" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24">
              <path d="M4 14.899A7 7 0 1 1 15.71 8h1.79a4.5 4.5 0 0 1 2.5 8.242" />
              <path d="M12 12v9m4-4-4-4-4 4" />
            </svg>
            <p class="text-lg font-medium">点击上传 PDF 或 ZIP</p>
          </div>
          <div v-else ref="pdfContainerRef" class="w-full flex flex-col min-h-full"></div>
        </div>
      </section>

      <section class="flex-1 flex flex-col min-w-0 transition-colors duration-300 bg-white dark:bg-slate-900">
        <div class="h-14 px-3 border-b font-mono text-sm flex justify-between items-center transition-colors duration-300 bg-slate-50 border-slate-200 text-blue-600 dark:bg-slate-800/50 dark:border-slate-700 dark:text-blue-400">
          <span>中文翻译</span>
          <div class="flex gap-2">
            <button
              v-if="currentProblem?.translation && !currentProblem.isTranslating"
              class="btn-secondary"
              title="重新生成翻译"
              @click="translateCurrentProblem"
            >
              <svg class="w-4 h-4" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24">
                <path d="M3 12a9 9 0 0 1 9-9 9.75 9.75 0 0 1 6.74 2.74L21 8M21 3v5h-5M21 12a9 9 0 0 1-9 9 9.75 9.75 0 0 1-6.74-2.74L3 16M8 16H3v5" />
              </svg>
              重译
            </button>
            <button
              v-if="currentProblem?.translation"
              class="btn-secondary"
              @click="currentProblem?.translation && handleAppCopy(currentProblem.translation)"
            >
              <svg v-if="isCopied" class="w-4 h-4" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24">
                <polyline points="20 6 9 17 4 12" />
              </svg>
              <svg v-else class="w-4 h-4" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24">
                <rect width="14" height="14" x="8" y="8" rx="2" ry="2" />
                <path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2" />
              </svg>
              {{ isCopied ? '已复制' : '复制' }}
            </button>
            <button
              v-if="currentProblem && !currentProblem.isTranslating && !currentProblem.translation"
              class="btn-primary"
              @click="translateCurrentProblem"
            >
              <svg class="w-4 h-4" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24">
                <path d="m5 8 6 6m-7 0 6-6 2-3M2 5h12M7 2h1m14 20-5-10-5 10m1-4h6" />
              </svg>
              开始翻译
            </button>
          </div>
        </div>
        <div class="flex-1 overflow-y-auto p-8 bg-white dark:bg-[#0f172a] relative">
          <div
            v-if="currentProblem?.error"
            class="bg-red-50 border border-red-200 text-red-700 dark:bg-red-900/30 dark:border-red-700 dark:text-red-200 p-4 rounded-lg mb-4"
          >
            {{ currentProblem.error }}
          </div>
          <div v-if="currentProblem?.isTranslating" class="absolute left-1/2 -translate-x-1/2 flex flex-col items-center opacity-70" style="top: 300px;">
            <div class="loader mb-6"></div>
            <p class="text-blue-600 dark:text-blue-300 text-lg animate-pulse">AI 正在翻译...</p>
          </div>
          <div v-else-if="currentProblem?.translation" class="markdown-body" v-html="translationHtml"></div>
          <div v-else class="h-full flex flex-col items-center justify-center text-slate-400 dark:text-slate-500">
            <svg class="w-5 h-5" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24">
              <path d="M5 12h14m-7-7 7 7-7 7" />
            </svg>
            <p class="mt-4">准备就绪，点击上方翻译按钮</p>
          </div>
        </div>
      </section>
    </main>

    <div
      v-if="showZipModal"
      class="fixed inset-0 bg-black/50 dark:bg-black/80 flex items-center justify-center z-50 p-4 backdrop-blur-sm"
    >
      <div class="bg-white dark:bg-slate-800 rounded-xl p-8 max-w-lg w-full border border-slate-200 dark:border-slate-700 shadow-2xl">
        <h2 class="text-2xl font-bold text-slate-900 dark:text-white mb-4">比赛多题翻译</h2>
        <p class="text-slate-600 dark:text-slate-300 mb-6">
          上传包含多个题目 PDF 的 .zip 压缩包。系统将自动解析文件并生成导航栏。
        </p>
        <div v-if="isProcessingZip" class="h-48 flex flex-col items-center justify-center">
          <div class="loader mb-4"></div>
          <p class="text-slate-500 dark:text-slate-400">正在解压并分析 ZIP...</p>
        </div>
        <div
          v-else
          class="border-2 border-dashed border-slate-300 dark:border-slate-600 rounded-xl h-48 flex flex-col items-center justify-center cursor-pointer hover:border-blue-500 hover:bg-blue-50 dark:hover:bg-slate-700/50 transition-all"
          @click="zipInputRef?.click()"
          @dragover.prevent
          @drop="handleZipDrop"
        >
          <input
            ref="zipInputRef"
            type="file"
            class="hidden"
            accept=".zip"
            @change="(event: Event) => {
              const input = event.target as HTMLInputElement
              const file = input.files?.[0]
              if (file) handleZipFile(file)
              input.value = ''
            }"
          />
          <svg class="w-6 h-6" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24">
            <path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71" />
            <path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71" />
          </svg>
          <p class="mt-4 text-lg font-medium text-slate-700 dark:text-slate-200">点击上传 .zip 比赛包</p>
        </div>
        <div class="mt-6 flex justify-end">
          <button class="text-slate-500 hover:text-slate-700 dark:text-slate-400 dark:hover:text-white" @click="showZipModal = false">
            取消
          </button>
        </div>
      </div>
    </div>

    <div
      v-if="showKeyModal"
      class="fixed inset-0 bg-black/50 dark:bg-black/80 flex items-center justify-center z-50 p-4 backdrop-blur-sm"
    >
      <div class="bg-white dark:bg-slate-800 rounded-xl p-6 max-w-md w-full border border-slate-200 dark:border-slate-700 shadow-2xl">
        <h2 class="text-xl font-bold text-slate-900 dark:text-white mb-4">设置 DeepSeek API Key</h2>
        <input
          v-model="apiKey"
          type="password"
          placeholder="sk-..."
          class="w-full bg-slate-50 border border-slate-300 dark:bg-slate-900 dark:border-slate-700 dark:text-white rounded p-3 focus:outline-none focus:border-blue-500 mb-4"
        />
        <div class="flex justify-end gap-3">
          <button
            class="bg-blue-600 hover:bg-blue-500 text-white px-4 py-2 rounded font-medium disabled:opacity-60"
            :disabled="!apiKey"
            @click="saveApiKey(apiKey)"
          >
            保存并继续
          </button>
        </div>
      </div>
    </div>
  </div>
</template>

<style scoped>
@import url('https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;700&family=Inter:wght@400;600;700&display=swap');

/* Button Styles */
button {
  display: inline-flex;
  align-items: center;
  justify-content: center;
  gap: 0.5rem;
  transition: all 0.2s;
}

.btn-primary {
  background-color: #4f46e5;
  color: white;
  padding: 0.375rem 0.75rem;
  border-radius: 0.375rem;
  font-size: 0.875rem;
  font-weight: 500;
}

.btn-primary:hover {
  background-color: #4338ca;
}

.btn-secondary {
  color: #64748b;
  padding: 0.25rem 0.75rem;
  border-radius: 0.375rem;
  font-size: 0.75rem;
  font-weight: 500;
}

.btn-secondary:hover {
  background-color: #e2e8f0;
}

.dark .btn-secondary {
  color: #e2e8f0;
}

.dark .btn-secondary:hover {
  background-color: #334155;
}

.btn-icon {
  padding: 0.5rem;
  border-radius: 9999px;
  color: #64748b;
}

.btn-icon:hover {
  background-color: #e2e8f0;
}

.dark .btn-icon {
  color: #cbd5e1;
}

.dark .btn-icon:hover {
  background-color: #334155;
}

.btn-text {
  color: #64748b;
  font-size: 0.875rem;
}

.btn-text:hover {
  color: #1e293b;
}

.dark .btn-text {
  color: #cbd5e1;
}

.dark .btn-text:hover {
  color: white;
}

:global(body) {
  font-family: 'Inter', sans-serif;
  margin: 0;
  background-color: #f8fafc;
  transition: background-color 0.3s, color 0.3s;
}

.font-mono,
.markdown-body code,
pre,
code {
  font-family: 'JetBrains Mono', monospace;
}

::-webkit-scrollbar {
  width: 8px;
  height: 8px;
}

::-webkit-scrollbar-track {
  background: transparent;
}

::-webkit-scrollbar-thumb {
  background: #cbd5e1;
  border-radius: 4px;
}

.dark ::-webkit-scrollbar-thumb {
  background: #475569;
}

.dark ::-webkit-scrollbar-thumb:hover {
  background: #64748b;
}

:deep(.markdown-body h1) {
  font-size: 1.9em;
  font-weight: 700;
  margin-bottom: 0.75em;
  color: #2563eb;
  line-height: 1.3;
}

.dark :deep(.markdown-body h1) {
  color: #60a5fa !important;
}

:deep(.markdown-body h2) {
  font-size: 1.5em;
  font-weight: 600;
  margin-top: 1.5em;
  margin-bottom: 0.75em;
  color: #3b82f6;
  border-bottom: 1px solid #e2e8f0;
  padding-bottom: 0.3em;
}

.dark :deep(.markdown-body h2) {
  color: #93c5fd !important;
  border-bottom-color: #334155;
}

:deep(.markdown-body h3) {
  font-size: 1.25em;
  font-weight: 600;
  margin-top: 1.25em;
  margin-bottom: 0.5em;
  color: #1d4ed8;
}

.dark :deep(.markdown-body h3) {
  color: #bfdbfe !important;
}

:deep(.markdown-body p) {
  margin-bottom: 1.2em;
  line-height: 1.8;
  color: #374151;
}

.dark :deep(.markdown-body p) {
  color: #e5e7eb !important;
}

:deep(.markdown-body ul),
:deep(.markdown-body ol) {
  padding-left: 1.5em;
  margin-bottom: 1.2em;
  color: #4b5563;
}

.dark :deep(.markdown-body ul),
.dark :deep(.markdown-body ol) {
  color: #d1d5db !important;
}

:deep(.markdown-body li) {
  color: inherit;
}

.dark :deep(.markdown-body li) {
  color: #e5e7eb !important;
}

:deep(.markdown-body :not(pre) > code) {
  background-color: #f1f5f9;
  padding: 0.2em 0.5em;
  border-radius: 6px;
  font-family: 'JetBrains Mono', monospace;
  font-size: 0.95em;
  color: #d97706;
  border: 1px solid #e2e8f0;
}

.dark :deep(.markdown-body :not(pre) > code) {
  background-color: #1e293b !important;
  color: #fbbf24 !important;
  border-color: #334155;
}

:deep(.markdown-body pre) {
  background-color: #f8fafc;
  padding: 1.1em;
  border-radius: 12px;
  overflow-x: auto;
  margin: 0;
  border: 1px solid #e2e8f0;
  font-family: 'JetBrains Mono', monospace;
}

.dark :deep(.markdown-body pre) {
  background-color: #0f172a !important;
  border-color: #334155;
}

:deep(.markdown-body pre code) {
  background-color: transparent;
  padding: 0;
  color: #334155;
  border: none;
  font-size: 0.95em;
}

.dark :deep(.markdown-body pre code) {
  color: #e2e8f0 !important;
}

:deep(.markdown-body blockquote) {
  border-left: 4px solid #3b82f6;
  padding-left: 1em;
  color: #6b7280;
  font-style: italic;
  background: #f1f5f9;
  padding: 0.5em 1em;
  border-radius: 0 4px 4px 0;
}

.dark :deep(.markdown-body blockquote) {
  color: #d1d5db !important;
  background: #1e293b;
}

:deep(.markdown-body table) {
  width: 100%;
  border-collapse: collapse;
  margin-bottom: 1em;
  border: 1px solid #e2e8f0;
}

:deep(.markdown-body th),
:deep(.markdown-body td) {
  border: 1px solid #e2e8f0;
  padding: 0.75em;
  color: #374151;
}

.dark :deep(.markdown-body th),
.dark :deep(.markdown-body td) {
  border-color: #334155;
  color: #e5e7eb !important;
}

:deep(.markdown-body th) {
  background-color: #f1f5f9;
  font-weight: 600;
}

.dark :deep(.markdown-body th) {
  background-color: #1e293b;
}

:deep(.markdown-body a) {
  color: #2563eb;
  text-decoration: underline;
  text-decoration-thickness: 2px;
}

.dark :deep(.markdown-body a) {
  color: #93c5fd !important;
}

:deep(.markdown-body strong),
:deep(.markdown-body b) {
  color: inherit;
  font-weight: 700;
}

:deep(.markdown-body em),
:deep(.markdown-body i) {
  color: inherit;
  font-style: italic;
}

:deep(.markdown-body) {
  max-width: 78ch;
  margin: 0 auto;
  color: #1f2937;
}

.dark :deep(.markdown-body) {
  color: #e5e7eb !important;
}

mjx-container {
  color: #1e293b !important;
}

.dark mjx-container {
  color: #e5e7eb !important;
}

.loader {
  border: 3px solid #e2e8f0;
  border-top: 3px solid #3b82f6;
  border-radius: 50%;
  width: 32px;
  height: 32px;
  animation: spin 1s linear infinite;
}

.dark .loader {
  border-color: #1e293b;
  border-top-color: #3b82f6;
}

@keyframes spin {
  0% {
    transform: rotate(0deg);
  }
  100% {
    transform: rotate(360deg);
  }
}

/* 优化Canvas渲染质量 - 高质量平滑渲染 */
canvas {
  image-rendering: auto;
  image-rendering: -webkit-optimize-contrast;
  backface-visibility: hidden;
  -webkit-backface-visibility: hidden;
  transform: translateZ(0);
  -webkit-transform: translateZ(0);
}

</style>
